# Title

* Привет; представиться
* Курс по Embedded Linux Kernel
  - т.е. будут рассмотрены не только фундаментальные части ядра, но и работа
    с устройствами, написание драйверов, отладка в железе и т.д.
* Любая работа начинается с подготовки рабочего окружения, установки
  необходимого софта, скачивания исходных кодов проектов, с которыми мы будем
  работать
  - все эти инструкции по сборке есть в методичке, которую я скину
  - это будет домашняя работа
* Первые две лекции будут не по ядру
* Эта лекция:
  - задаёт контекст (добавляет мета-информацию), чтобы было понятно,
    как всё устроено, и почему были приняты такие решения
  - подробно рассматривает:
     - железо, с которым мы будем работать
     - программные компоненты
     - и процесс их сборки

## Organization

### Linux Kernel ProCamp Details

* Карантин; удалённый курс

### Mentros

* Oleksandr Redchuk: лекции по фундаментальной части:
  - планировщик
  - виртуальная память
  - примитивы синхронизации
  - таймеры, и т.д.
* Sam Protsenko: лекции по Embedded части:
  - подготовка железа и софта
  - написание драйверов
  - взаимодействие с внешними устройствами
  - отладка в железе
* Andrii Lukin: лекции по memory management
* Vitalii Vasylskyy: тоже Embedded часть:
  - device tree
  - platform devices
  - character devices
* Illia Smyrnov:
  - system calls
  - sysfs
  - block devices
* Ruslan Bilovol: USB

## Hardware Overview

### Embedded Systems

* Embedded (встраиваемая) система: не самостоятельное устройство, как
  персональный компьютер, а компьютер, как часть другого устройства
* Linux в Embedded; real-time

### Embedded Programming

### Kernel: Big Picture

* Далее мы будем говорить про железо и про user-space (т.е. пользовательские
  программы, которые управляются ядром)
  - основная задача ядра это распределение ресурсов процессора и оперативной
    памяти между программами
  - но также ядро является прослойкой между аппаратными устройствами и
    пользовательскими программами
  - устройства предоставляют аппаратный интерфейс для работы с ними
    (регистры, прерывания), которое использует ядро в своём коде
  - ядро предоставляет интерфейс ядра в пространство пользователя (системные
    вызовы, виртуальные файлы), чтобы пользовательские программы могли выполнять
    такие действия, как вывод графики на экран, обработка нажатий клавиш на
    клавиатуре, вывод текста в консоль
  - соответственно из этого рисунка становится понятно, что для успешного
    программирования в пространстве ядра необходимо хорошо понимать с одной
    стороны железо и его интерфейсы, с другой стороны понимать, какие интерфейсы
    предоставляет ядро в пространство пользователя, и уметь использовать эти
    интерфейсы
  - можно думать об этом так: чтобы стать авто-механиком, неплохо для начала
    понять, что такое руль, педали и передачи
  - так что давайте для начала рассмотрим, с каким железом мы будем работать

### Cortex A/R/M Families

* В Embedded системах на данный момент чаще всего применяются процессоры
  компании ARM, и самая популярная серия называется Cortex
* Есть 3 семейства процессоров ARM Cortex:
  - M: Microcontrollers
  - R: Real-time
  - A: Application; нас интересует это семейство

### AM335x SoC

* Процессоры ARM физически чаще всего не являются отдельной микросхемой, а
  являются частю более сложной микросхемы
* SoC = System-on-Chip: включает в себя процессор, видео-ядро, контроллер
  дисплея, и аппаратные модули для работы с разнообразной периферией
* На плате, которую мы будем использовать, установлен AM3358 SoC
* Самая важная часть SoC это процессор Cortex-A8
  - в нашем случае содержит всего одно процессорное ядро
  - которое содержит ЦПУ: ARMv7-A
