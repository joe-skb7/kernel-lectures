+ assignment (optional): power management
+ assignment (optional): overlays

- read(): what if user requested 1 byte? we still give him 2 bytes... it's
  an overflow; fix in my module3 driver

- tell about BBB capes and why we are not using them
- LED + PWM
- show used kernel API (ioremap, gpio, of_, platform driver, char device, etc)
  (appendix)?
- Add slide with electrical components (symbol + photo + name)?
- Split this lecture into 2 lectures:
    1. Till attempt #3, + workshop (build device) + homework: test it works
    2. Attempt #3, userspace, etc. Homework: keypad
- I_f = I_LED
- Revise commands in appendix A
- Add by-line explanation for each driver? Or just show it via vim?
- For attempt #1: mention possible race condition for GPIO set
  (or use atomic set/clear registers instead)
- Add references (LDD3, Bootlin slides, related kernel documentation)
- Add clock introspection
- Add prerequisites: bring BBB and laptop
- Split attempt #3 (at least) into logical chunks: pm, registering, ioctl, etc.
- Add info about GPIO controller driver (device tree, driver, compatible,
  kernel frameworks for that, etc); this is what allows us to write
  architecture-independent (cross-platform) driver
- Add interconnect explanation (benefitc vs conventional bus)?
- Explain about binding documentation (related)
- Add "Questions?" to "Thank you!" slide, like on my first lecture
- Show GPIO controller driver, device tree, etc
  - that's how platform-independent GPIO API is done
- Why only "scan" or only "read" pins are pulled-up on fig. 19-20? Should
  pull-up all lines probably
- If split into 2 lectures: probably add input_dev API and ask students to
  report found key to linux (in assignment)
- After split: add GPIO user-space API (old, new) and GPIO internals to the
  first lecture, and all code move to second lecture

